/* -*- mode: c++; indent-tabs-mode: nil -*- */
/** @file ZSocket.qpp defines the ZSocket class */
/*
  QC_ZSocket.qpp

  Qore Programming Language

  Copyright (C) 2017 Qore Technologies, s.r.o.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "zmq-module.h"

#include "QC_ZSocket.h"
#include "QC_ZMsg.h"
#include "QC_ZFrame.h"

#include <zmsg.h>
#include <zframe.h>
#include <zmq.h>

/** @defgroup zsocket_events ZSocket Events
    These constants define event codes for @ref Qore::ZMQ::ZSocket::monitor() "ZSocket::monitor()"
    and are meant to be combined with binary or to create a socket event mask.
*/
//@{
//! mask for all events
const ZMQ_EVENT_ALL = 0xFFFF;

//! connected event
/** The socket has successfully connected to a remote peer. The event value is the file descriptor (FD) of the underlying network socket. Warning: there is no guarantee that the FD is still valid by the time your code receives this event.
*/
const ZMQ_EVENT_CONNECTED = 0x0001;

//! delayed event
/** A connect request on the socket is pending. The event value is unspecified.
*/
const ZMQ_EVENT_CONNECT_DELAYED = 0x0002;

//! retried event
/** A connect request failed, and is now being retried. The event value is the reconnect interval in milliseconds. Note that the reconnect interval is recalculated at each retry.
*/
const ZMQ_EVENT_CONNECT_RETRIED = 0x0004;

//! listening event
/** The socket was successfully bound to a network interface. The event value is the FD of the underlying network socket. Warning: there is no guarantee that the FD is still valid by the time your code receives this event.
*/
const ZMQ_EVENT_LISTENING = 0x0008;

//! bind failed event
/** The socket could not bind to a given interface. The event value is the errno generated by the system bind call.
*/
const ZMQ_EVENT_BIND_FAILED = 0x0010;

//! accepted event
/** The socket has accepted a connection from a remote peer. The event value is the FD of the underlying network socket. Warning: there is no guarantee that the FD is still valid by the time your code receives this event.
*/
const ZMQ_EVENT_ACCEPTED = 0x0020;

//! accept failed event
/** The socket has rejected a connection from a remote peer. The event value is the errno generated by the accept call.
*/
const ZMQ_EVENT_ACCEPT_FAILED = 0x0040;

//! closed event
/** The socket was closed. The event value is the FD of the (now closed) network socket.
*/
const ZMQ_EVENT_CLOSED = 0x0080;

//! close failed event
/** The socket close failed. The event value is the errno returned by the system call. Note that this event occurs only on IPC transports.
*/
const ZMQ_EVENT_CLOSE_FAILED = 0x0100;

//! disconnected event
/** The socket was disconnected unexpectedly. The event value is the FD of the underlying network socket. Warning: this socket will be closed.
*/
const ZMQ_EVENT_DISCONNECTED = 0x0200;

//! monitor stopped event
/** Monitoring on this socket ended.
*/
const ZMQ_EVENT_MONITOR_STOPPED = 0x0400;

//! ZeroMQ event map mapping event codes to strings
const ZmqEventCodeMap = (
    "1": "ZMQ_EVENT_CONNECTED",
    "2": "ZMQ_EVENT_CONNECT_DELAYED",
    "4": "ZMQ_EVENT_CONNECT_RETRIED",
    "8": "ZMQ_EVENT_LISTENING",
    "16": "ZMQ_EVENT_BIND_FAILED",
    "32": "ZMQ_EVENT_ACCEPTED",
    "64": "ZMQ_EVENT_ACCEPT_FAILED",
    "128": "ZMQ_EVENT_CLOSED",
    "256": "ZMQ_EVENT_CLOSE_FAILED",
    "512": "ZMQ_EVENT_DISCONNECTED",
    "1024": "ZMQ_EVENT_MONITOR_STOPPED",
);

//! ZeroMQ event map mapping strings to event codes
const ZmqEventStringMap = (
    "ZMQ_EVENT_CONNECTED": 0x0001,
    "ZMQ_EVENT_CONNECT_DELAYED": 0x0002,
    "ZMQ_EVENT_CONNECT_RETRIED": 0x0004,
    "ZMQ_EVENT_LISTENING": 0x0008,
    "ZMQ_EVENT_BIND_FAILED": 0x0010,
    "ZMQ_EVENT_ACCEPTED": 0x0020,
    "ZMQ_EVENT_ACCEPT_FAILED": 0x0040,
    "ZMQ_EVENT_CLOSED": 0x0080,
    "ZMQ_EVENT_CLOSE_FAILED": 0x0100,
    "ZMQ_EVENT_DISCONNECTED": 0x0200,
    "ZMQ_EVENT_MONITOR_STOPPED": 0x0400,
);
//@}

//! The ZSocket class provides the abstract base class for ZeroMQ socket classes
/** @note
    - The ZSocket class is not designed to be accessed from multiple threads; it was created without
      locking for fast and efficient use when used from a single thread.  For methods that would be
      unsafe to use in another thread, any use of such methods in threads other than the thread where the constructor was called will cause a \c ZSOCKET-THREAD-ERROR to be thrown.
 */
qclass ZSocket [arg=QoreZSock* zsock; ns=Qore::ZMQ; dom=NETWORK];

//! Private constructor; use a child class instead
/**
 */
abstract private:internal ZSocket::constructor() {
    // this method can never be called
    assert(false);
}

//! Throws an exception; copying ZSocket objects is not currently supported
/** @throw ZSOCKET-COPY-ERROR copying ZSocket objects is not currently supported
*/
ZSocket::copy() {
    xsink->raiseException("ZSOCKET-COPY-ERROR", "copying ZSocket objects is not currently supported");
}

//! Creates a bound \c PAIR socket on the given endpoint which will send the specified events to a single client
/** @par Examples:
    @code{.py}
zsock.monitor(ZMQ_EVENT_ALL, "inproc://monitor-socket-1");
    @endcode

    @param events an event code mask combined with binary or; see @ref zsocket_events for possible values
    @param format the format string for the @ref zmqendpoints "endpoint", which must be an \c "inproc://" endpoint
    @param ... optional arguments for the format string

    @throw ZSOCKET-MONITOR-ERROR this exception is thrown if the internal call to \c zmq_socket_monitor() fails
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created

    @note This method supports only \c "inproc://" endpoints
*/
nothing ZSocket::monitor(int events, string format, ...) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    SimpleRefHolder<QoreStringNode> str(q_sprintf(args, 0, 1, xsink));
    if (*xsink)
        return QoreValue();

    // zmq_socket_monitor() returns 0 = OK, -1 = error
    int rc = zmq_socket_monitor(**zsock, str->c_str(), events);
    if (rc < 0)
        zmq_error(xsink, "ZSOCKET-MONITOR-ERROR", "error in ZSocket::monitor(" QLLD ", \"%s\")", events, str->c_str());
}

//! Bind the ZSocket to a formatted @ref zmqendpoints "endpoint"
/** @par Examples:
    @code{.py}
# bind to a random port
int port = zsock.bind("tcp://127.0.0.1:*");
# bind to a random port
port = zsock.bind("tcp://127.0.0.1:0");
    @endcode

    For \c tcp:// endpoints, this class supports ephemeral ports if you
    specify the port number as "*" or \ "0".

    @param format the format string for the @ref zmqendpoints "endpoint"
    @param ... optional arguments for the format string

    @return the actual port number used for \c "tcp://" endpoints,
    0 for other transports. On failure, a \c ZSOCKET-BIND-ERROR exception is thrown.
    Note that when using ephemeral ports, a port may be reused by different services without
    clients being aware of this fact.  Protocols that run on ephemeral ports should take
    this into account.

    @throw ZSOCKET-BIND-ERROR if an error occurs, this exception is thrown
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created

    @note do not use the endpoint prefix \c "@" with this method
 */
int ZSocket::bind(string format, ...) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    SimpleRefHolder<QoreStringNode> str(q_sprintf(args, 0, 0, xsink));
    if (*xsink)
        return QoreValue();

    return zsock->bind(xsink, str->c_str());
}

//! Returns the last bound @ref zmqendpoints "endpoint", if any or @ref nothing if not
/** @par Examples:
    @code{.py}
*string endpoint = zsock.endpoint();
    @endcode

    @return the last bound @ref zmqendpoints "endpoint", if any or @ref nothing if not

    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
*/
*string ZSocket::endpoint() [flags=CONSTANT] {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    // get endpoint
    SimpleRefHolder<QoreStringNode> rv(new QoreStringNode);
    rv->reserve(1024);

    size_t size = 1024;
    int rc = zmq_getsockopt(**zsock, ZMQ_LAST_ENDPOINT, (void*)rv->c_str(), &size);
    if (rc)
        return QoreValue();
    rv->terminate(strlen(rv->c_str()));
    return rv.release();
}

//! Unbinds the socket from a formatted @ref zmqendpoints "endpoint"
/** @par Examples:
    @code{.py}
zsock.unbind(str);
    @endcode

    @param format the format string for the @ref zmqendpoints "endpoint"
    @param ... optional arguments for the format string

    Throws an exception if the @ref zmqendpoints "endpoint" was invalid or the function isn't supported on the current socket

    @throw ZSOCKET-UNBIND-ERROR thrown if the @ref zmqendpoints "endpoint" was invalid or the function isn't supported on the current socket
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created

*/
nothing ZSocket::unbind(string format, ...) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    SimpleRefHolder<QoreStringNode> str(q_sprintf(args, 0, 0, xsink));
    if (*xsink)
        return QoreValue();

    int rc = zmq_unbind(**zsock, str->c_str());
    if (rc < 0)
        zmq_error(xsink, "ZSOCKET-UNBIND-ERROR", "error in ZSocket::unbind(\"%s\")", str->c_str());
}

//! Connects the socket to a formatted @ref zmqendpoints "endpoint"
/** @par Examples:
    @code{.py}
zsock.unbind(str);
    @endcode

    @param format the format string for the @ref zmqendpoints "endpoint"
    @param ... optional arguments for the format string

    Throws an exception if an error occurs connecting to the @ref zmqendpoints "endpoint"

    @throw ZSOCKET-CONNECT-ERROR thrown if an error occurs connecting to the @ref zmqendpoints "endpoint"
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created

    @note do not use the endpoint prefix \c ">" with this method
 */
nothing ZSocket::connect(string format, ...) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    SimpleRefHolder<QoreStringNode> str(q_sprintf(args, 0, 0, xsink));
    if (*xsink)
        return QoreValue();

    zsock->connect(xsink, str->c_str());
}

//! Disconnects the socket from a formatted @ref zmqendpoints "endpoint"
/** @par Examples:
    @code{.py}
zsock.disconnect(str);
    @endcode

    @param format the format string for the @ref zmqendpoints "endpoint"
    @param ... optional arguments for the format string

    Throws an exception if the @ref zmqendpoints "endpoint" was invalid or the function isn't supported on the current socket

    @throw ZSOCKET-DISCONNECT-ERROR thrown if the @ref zmqendpoints "endpoint" was invalid or the function isn't supported on the current socket
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
*/
nothing ZSocket::disconnect(string format, ...) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();


    SimpleRefHolder<QoreStringNode> str(q_sprintf(args, 0, 0, xsink));
    if (*xsink)
        return QoreValue();

    int rc = zmq_disconnect(**zsock, str->c_str());
    if (rc < 0)
        zmq_error(xsink, "ZSOCKET-DISCONNECT-ERROR", "error in ZSocket::disconnect(\"%s\")", str->c_str());
}

//! Attaches the socket to zero or more @ref zmqendpoints "endpoints"
/** @par Examples:
    @code{.py}
zsock.attach(endpoints_str, True);
    @endcode

    @param endpoints zero or more @ref zmqendpoints "endpoints", separated by commas and prefixed by \c '@' (to bind the socket) or \c '>' (to connect the socket)
    @param do_bind determines if endpoints not prefixed with \c '@' or \c '>' are bound (\a do_bind = @ref Qore::True "True") or connected (\a do_bind = @ref Qore::False "False", the default)

    Throws an exception if there was a syntax error in the \a endpoints argument

    @throw ZSOCKET-CONNECT-ERROR thrown if there is a connect error
    @throw ZSOCKET-BIND-ERROR thrown if there is a bind error
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
*/
nothing ZSocket::attach(*string endpoints, bool do_bind = False) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    zsock->attach(xsink, endpoints ? endpoints->c_str() : nullptr, do_bind);
}

//! Returns the socket type as a string
/** @par Example:
    @code{.py}
string type = zsock.type();
    @endcode

    @return the socket type as a string
 */
string ZSocket::type() [flags=CONSTANT] {
    return new QoreStringNode(zsock->getTypeName());
}

//! Sends the given message over the socket; the message is consumed by this call
/** @par Example:
    @code{.py}
zsock.send(msg);
    @endcode

    @param msg the message to send; the argument object will be deleted as it is consumed by this call; if the message is empty then no data is sent, but the object is destroyed in any case

    @throw ZSOCKET-SEND-ERROR thrown if an error occurs during the call
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
*/
nothing ZSocket::send(Qore::ZMQ::ZMsg[QoreZMsg] msg) {
    ReferenceHolder<QoreZMsg> holder(msg, xsink);
    {
        // enforce access from the correct thread
        if (zsock->check(xsink))
            return QoreValue();

        int rc = zmsg_send(msg->getPtr(), **zsock);
        if (rc < 0)
            zmq_error(xsink, "ZSOCKET-SEND-ERROR", "error in ZSocket::send(%s)", obj_msg->getClassName());
    }
    if (!msg->getPtr())
        const_cast<QoreObject*>(obj_msg)->doDelete(xsink);
}

//! Waits for data to read on the socket; if data does not arrive before the timeout expires, a \c ZSOCKET-TIMEOUT exception is thrown
/** @par Example:
    @code{.py}
zsock.waitRead(10s);
    @endcode

    @param timeout_ms the timeout in milliseconds

    @throw ZSOCKET-TIMEOUT this exception is thrown if data does not arrive before the timeout expires
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
*/
nothing ZSocket::waitRead(timeout timeout_ms) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    zsock->poll(ZMQ_POLLIN, timeout_ms, "ZSocket::waitRead", xsink);
}

//! Waits for data to be written on the socket; if data is not sent before the timeout expires, a \c ZSOCKET-TIMEOUT exception is thrown
/** @par Example:
    @code{.py}
zsock.waitWrite(10s);
    @endcode

    @param timeout_ms the timeout in milliseconds

    @throw ZSOCKET-TIMEOUT this exception is thrown if the data is not sent before the timeout expires
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
*/
nothing ZSocket::waitWrite(timeout timeout_ms) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    zsock->poll(ZMQ_POLLOUT, timeout_ms, "ZSocket::waitWrite", xsink);
}

//! Sends the given frame over the socket; the frame is consumed by this call unless @ref Qore::ZMQ::ZFRAME_REUSE is used in the \a flags argument
/** @par Example:
    @code{.py}
zsock.send(frame);
    @endcode

    @param frame the frame to send; if \a does not contain @ref Qore::ZMQ::ZFRAME_REUSE, the argument object will be deleted by this call; if the frame is empty then no data is sent
    @param flags a bitwise-or combination of zero or more of @ref zframe_flags; to send a frame in non-blocking mode, use the @ref Qore::ZMQ::ZFRAME_DONTWAIT flag

    @throw ZSOCKET-SEND-ERROR thrown if an error occurs during the call
    @throw ZSOCKET-SEND-WAIT-ERROR if the @ref Qore::ZMQ::ZFRAME_DONTWAIT flag is used and the message cannot be queued on the socket, this exception is thrown
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
*/
nothing ZSocket::send(Qore::ZMQ::ZFrame[QoreZFrame] frame, int flags = 0) {
    ReferenceHolder<QoreZFrame> holder(frame, xsink);
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();
    {
        int rc = zframe_send(frame->getPtr(), **zsock, flags);
        if (rc < 0) {
            if (flags & ZFRAME_DONTWAIT && errno == EAGAIN)
                zmq_error(xsink, "ZSOCKET-SEND-WAIT-ERROR", "error in ZSocket::send(%s)", obj_frame->getClassName());
            else
                zmq_error(xsink, "ZSOCKET-SEND-ERROR", "error in ZSocket::send(%s)", obj_frame->getClassName());
        }
    }
    if (!(flags & ZFRAME_REUSE) && !frame->getPtr())
        const_cast<QoreObject*>(obj_frame)->doDelete(xsink);
}

//! Receives a frame from the socket
/** @par Example:
    @code{.py}
ZFrame frm = zsock.recvFrame();
    @endcode

    @return the frame received from the socket

    @throw ZSOCKET-RECVFRAME-ERROR thrown if an error occurs during the call
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
*/
ZFrame ZSocket::recvFrame() {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();
    zframe_t* frm = zframe_recv(**zsock);
    if (!frm) {
        zmq_error(xsink, "ZSOCKET-RECVFRAME-ERROR", "error in ZSocket::recvFrame()");
        return QoreValue();
    }
    return new QoreObject(QC_ZFRAME, getProgram(), new QoreZFrame(frm));
}

//! Receives a message from the socket
/** @par Example:
    @code{.py}
ZMsg frm = zsock.recvMsg();
    @endcode

    @return the messsage received from the socket

    @throw ZSOCKET-RECVMSG-ERROR thrown if an error occurs during the call
    @throw ZSOCKET-TIMEOUT thrown if a timeout error occurs
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
*/
ZMsg ZSocket::recvMsg() {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();
    zmsg_t* msg = zmsg_recv(**zsock);
    if (!msg) {
        zmq_error(xsink, "ZSOCKET-RECVMSG-ERROR", "error in ZSocket::recvMsg()");
        return QoreValue();
    }
    return new QoreObject(QC_ZMSG, getProgram(), new QoreZMsg(msg));
}

//! Sets the send timeout in milliseconds
/** @par Example:
    @code{.py}
zsock.setSendTimeout(30s);
    @endcode

    @param timeout_ms set the send timeout in milliseconds; like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw ZSOCKET-SETSENDTIMEOUT-ERROR if an error occurs setting the timeout option
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created

    @see
    - @ref ZSocket::setRecvTimeout()
    - @ref ZSocket::setTimeout()
 */
nothing ZSocket::setSendTimeout(timeout timeout_ms) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    int v = timeout_ms;
    while (true) {
        int rc = zmq_setsockopt(**zsock, ZMQ_SNDTIMEO, &v, sizeof v);
        if (rc) {
            if (errno == EINTR)
                continue;
            zmq_error(xsink, "ZSOCKET-SETSENDTIMEOUT-ERROR", "error in ZSocket::setSendTimeout()");
        }
    }
}

//! Sets the receive timeout in milliseconds
/** @par Example:
    @code{.py}
zsock.setRecvTimeout(30s);
    @endcode

    @param timeout_ms set the receive timeout in milliseconds; like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw ZSOCKET-SETRECVTIMEOUT-ERROR if an error occurs setting the timeout option
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created

    @see
    - @ref ZSocket::setSendTimeout()
    - @ref ZSocket::setTimeout()
 */
nothing ZSocket::setRecvTimeout(timeout timeout_ms) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    int v = timeout_ms;
    while (true) {
        int rc = zmq_setsockopt(**zsock, ZMQ_RCVTIMEO, &v, sizeof v);
        if (rc) {
            if (errno == EINTR)
                continue;
            zmq_error(xsink, "ZSOCKET-SETRECVTIMEOUT-ERROR", "error in ZSocket::setRecvTimeout()");
       }
    }
}

//! Sets the send and receive timeout in milliseconds
/** @par Example:
    @code{.py}
zsock.setTimeout(30s);
    @endcode

    @param timeout_ms set the send and receive timeout in milliseconds; like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw ZSOCKET-SETTIMEOUT-ERROR if an error occurs setting the timeout option
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created

    @see
    - @ref ZSocket::setRecvTimeout()
    - @ref ZSocket::setSendTimeout()
 */
nothing ZSocket::setTimeout(timeout timeout_ms) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    int v = timeout_ms;
    while (true) {
        int rc = zmq_setsockopt(**zsock, ZMQ_RCVTIMEO, &v, sizeof v);
        if (rc) {
            if (errno == EINTR)
                continue;
            zmq_error(xsink, "ZSOCKET-SETTIMEOUT-ERROR", "error setting receive timeout in ZSocket::setTimeout()");
            return QoreValue();
        }
    }
    v = timeout_ms;
    while (true) {
        int rc = zmq_setsockopt(**zsock, ZMQ_SNDTIMEO, &v, sizeof v);
        if (rc) {
            if (errno == EINTR)
                continue;
            zmq_error(xsink, "ZSOCKET-SETTIMEOUT-ERROR", "error setting send timeout in ZSocket::setTimeout()");
        }
    }
}

//! Sets the socket identity string
/** @par Example:
    @code{.py}
# create an unconnected ROUTER socket
ZSocketRouter router(zctx);
# set the router's identity value explicitly before binding
router.setIdentity(RouterIdentity);
port = router.bind("tcp://127.0.0.1:*");
    @endcode

    @param id the identity string to set on the socket; the string will be converted to UTF-8 encoding if necessary; cannot be an empty string or a \c ZSOCKET-SETIDENTITY-ERROR exception will be thrown

    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if an encoding error is encountered when converting the given string to UTF-8
    @throw ZSOCKET-SETIDENTITY-ERROR if an error occurs setting the identity option on the socket
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created

    @note
    - the identity takes affect in the next socket connection; if the socket is already connected, then it must be reconnected for the identity value set in this call to take effect
    - it is recommended to use an identity option with the following socket types:
      - @ref Qore::ZMQ::ZSocketReq "ZSocketReq": \c REQ
      - @ref Qore::ZMQ::ZSocketRep "ZSocketRep": \c REP
      - @ref Qore::ZMQ::ZSocketDealer "ZSocketDealer": \c DEALER
      - @ref Qore::ZMQ::ZSocketRouter "ZSocketRouter": \c ROUTER
 */
nothing ZSocket::setIdentity(string id) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    // NOTE: cannot use zsock_setidentity() here as it will assert for all sockets except REQ, REP, DEALER, and ROUTER
    zsock->setIdentity(*id, xsink);
}

//! retrieves the socket identity string
/** @par Example:
    @code{.py}
*string id = zsock.getIdentity();
    @endcode

    @return the socket identity string or @ref nothing if no value is set

    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
*/
*string ZSocket::getIdentity() [flags=CONSTANT] {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    char* str = zsock_identity(**zsock);
    if (!str)
        return QoreValue();

    size_t len = strlen(str);
    return new QoreStringNode(str, len, len + 1, QCS_UTF8);
}

//! Sends a string over the socket
/** @par Example:
    @code{.py}
zsock.send(str);
    @endcode

    @param str the string to send as a frame over the socket

    @throw ZSOCKET-SEND-ERROR an error occurred sending the data
    @throw ZSOCKET-TIMEOUT thrown if a timeout error occurs
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
 */
nothing ZSocket::send(string str) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    int rc = zstr_send(**zsock, str->c_str());
    if (rc)
        zmq_error(xsink, "ZSOCKET-SEND-ERROR", "error sending string");
}

//! Sends a binary object over the socket
/** @par Example:
    @code{.py}
zsock.send(bin);
    @endcode

    @param bin the binary object to send

    @throw ZSOCKET-SEND-ERROR an error occurred sending the data
    @throw ZSOCKET-TIMEOUT thrown if a timeout error occurs
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
*/
nothing ZSocket::send(binary bin) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    int rc = zsock_send(**zsock, "b", bin->getPtr(), (size_t)bin->size());
    if (rc)
        zmq_error(xsink, "ZSOCKET-SEND-ERROR", "error sending binary object");
}

//! Send a 'picture' message to the socket
/** @par Example:
    @code{.py}
zsock.send("i", i);
    @endcode

    @param picture a string that defines the type of each frame. This makes it easy to send a complex multiframe message in one call. The picture can contain any of these characters, each corresponding to one or two arguments:
    - \c i = \c int (signed)
    - \c 1 = \c uint8_t (i.e. an 8 bit / single byte value)
    - \c 2 = \c uint16_t (i.e. a 16 bit / 2-byte unsigned integer value)
    - \c 4 = \c uint32_t (i.e. a 32 bit / 4-byte unsigned integer value)
    - \c 8 = \c uint64_t (i.e. a 64 bit / 8-byte unsigned integer value)
    - \c s = \c string
    - \c b = \c binary
    - \c c = \c zchunk_t*
    - \c f = @ref Qore::ZMQ::ZFrame "ZFrame"
    - \c h = \c zhashx_t*
    - \c U = \c zuuid_t*
    - \c m = @ref Qore::ZMQ::ZMsg "ZMsg" (sends all frames in the zmsg)
    - \c z = sends zero-sized frame (0 arguments)
    .
    Note that s, b, c, and f are encoded the same way and the choice is
    offered as a convenience to the sender, which may or may not already
    have data in a zchunk or zframe. Does
    @param ... arguments corresponding to \a picture; if there are not enough arguments an exception is thrown

    @throw ZSOCKET-SENDPICTURE-ARG-ERROR there was an error processing the arguments for the send call
    @throw ZSOCKET-SENDPICTURE-ERROR an error occurred sending the data
    @throw ZSOCKET-TIMEOUT thrown if a timeout error occurs
    @throw ZSOCKET-THREAD-ERROR this exception is thrown if this method is called from a thread other than the thread where the object was created
*/
nothing ZSocket::sendPicture(string picture, ...) {
    // enforce access from the correct thread
    if (zsock->check(xsink))
        return QoreValue();

    int rc = zsock_vsend(**zsock, picture->c_str(), nullptr);//zargs);
    if (rc < 0)
        zmq_error(xsink, "ZSOCKET-SENDPICTURE-ERROR", "error in ZSocket::send()");
}
